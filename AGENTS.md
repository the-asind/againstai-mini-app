# AGENTS.md — Актуальный контекст и правила для ИИ (AgainstAI)

> **Роль:** Ты — опытный Fullstack разработчик (Node.js + React), работающий над проектом **AgainstAI Mini App**.
> **Цель:** Поддерживать чистоту кода, строго следовать текущей расширенной архитектуре (с интерактивными загрузками, сектантами, голосовой и визуальной генерацией) и использовать MCP для получения актуальной документации при необходимости.

---

## 1. Обзор Проекта (Project Overview)
**AgainstAI Mini App** — это Telegram Mini App, текстовый квест-выживач с асимметричным геймплеем, где игроки противостоят ИИ Гейм-Мастеру (Gemini API), а иногда друг другу (предатели/твисты).
- **Frontend:** React + Vite + TailwindCSS + TypeScript. Использует Telegram WebApp API (вкл. параметры темы и тактильную отдачу — HapticFeedback).
- **Backend:** Node.js (Express) + WebSocket (Socket.io) через `ts-node`.
- **AI Core:**
  - **Текст и Логика:** Google Gemini API (`@google/genai`). Форсированные JSON ответы. Запуск проверок на читы/инъекции, генерация сюжета, оценка выживания.
  - **Медиа:** Navy API (внутренний сервис на основе Prodia и TTS) — `imageService` (генерация изображений локаций и финальных сцен) и `voiceService` (ИИ-озвучка сюжета).

---

## 2. Архитектура и Ключевые Файлы (Code Map)

### Backend (`/server`)
Игровой движок (стейт-машина) и интеграции с нейросетями.

| Файл / Слой | Описание и Функции |
|-------------|-------------------|
| **`server/index.ts`** | Точка входа. Express сервер и инициализация Socket.io. Связывает вебсокет-события с методами `LobbyService`. |
| **`server/services/lobbyService.ts`** | **Менеджер состояний Lobbies.** Управляет фазами (`HOME` -> `LOBBY_WAITING` -> `SCENARIO_GENERATION` -> `PLAYER_INPUT` -> `JUDGING` -> `RESULTS`).<br> • Обработка таймеров фазы ввода хода.<br> • Синхронизация генерации (Текст -> Картинка -> Озвучка).<br> • Приватная рассылка индивидуальных ИИ-секретов (`emitSecrets`). |
| **`server/services/geminiService.ts`** | **Мозг Гейм-Мастера.** <br> • `generateScenario()`: Создает лор, локацию, и теперь **сразу же генерирует ИИ-секреты** (Асимметричный геймплей) для игроков одним LLM вызовом, чтобы сохранить контекст и сэкономить токены.<br> • `judgeRound()`: Оценивает действия, решает кто выжил с учетом секретных вводных игроков.<br> • `checkInjection()`: Базовая модерация текста игроков. |
| **`server/services/navyService.ts`, `imageService.ts`, `voiceService.ts`** | Клиенты для генерации визуального и аудио контента на основе сюжетов Gemini (используют отдельный ключ Navy Key). |
| **`server/prompts.ts`** | Системные промпты для LLM. |
| **`server/archetypes/*.ts`** | Хранилище лора. `twists.ts` отвечает за типы подлянок (шпион, параноик, предатель и т.д.). |
| **`server/poll.ts`** | Вопросы для фазы интерактивного голосования игроков (мини-игра на экране загрузки). |

### Frontend (`/src` и корень)
SPA клиент для Telegram Mini App.

| Файл / Слой | Описание |
|-------------|----------|
| **`App.tsx`** | Главный контейнер. Центральное состояние React (содержит подписки на сокеты: `game_state`, `secret_data`, `error`). Переключает виды в зависимости от `gameState.status`. |
| **`types.ts`** | **Single Source of Truth** типов. Содержит интерфейсы `Player`, `GameState`, `LobbySettings`, enum `GameStatus`, `LoadingPhase` и типы Telegram WebApp. Используется и на клиенте, и на сервере! |
| **`components/LobbyView.tsx`** | Экран лобби, меню настроек (API ключи, язык, генерация картинок/звука, сложность), список игроков. |
| **`components/InteractiveLoadingScreen.tsx`** | Экран мини-игры (`SCENARIO_GENERATION`). Занимает игроков кручением "Колеса Выбора" и дебатами (выбор "Кто скорее всего..."), пока Gemini и NavyServic'ы генерируют сценарий и картинку. |
| **`components/SecretModal.tsx`** | Всплывающее окно `ВХОДЯЩЕЕ СООБЩЕНИЕ`. Показывает игроку его скрытую роль или твист перед вводом хода. Использует тактильную отдачу (`HapticFeedback`) TWA для привлечения внимания. |
| **`components/MarkdownDisplay.tsx`** | Рендер Markdown от Gemini. Теперь поддерживает встроенный эффект "печатной машинки" (проп `animate={true}`) для красивого посимвольного появления сюжета. |
| **`services/socketService.ts`** | Клиентский слой Socket.io. |

---

## 3. Правила Кодинга (Development Conventions)

1. **Типизация превыше всего:** Если ты добавляешь новое поле (например, настройку лобби или свойство в ответ ИИ), **начинай с `types.ts`**. Затем обновляй методы бэкенда, и только потом интерфейс. Типы без `any`.
2. **Многофазная загрузка:** Генерация контента (сценарий + картинка + звук) занимает долгое время (иногда 10-15 секунд). Поэтому добавлены состояния `SCENARIO_GENERATION` с фазами `WHEEL`, `VOTING`, `VOTING_RESULTS`. Любые тяжелые вызовы (или цепочки ИИ-вызовов) должны покрываться UI-событиями для пользователей.
3. **Безопасность API Ключей:** В `lobbyService.ts` метод `emitUpdate()` **ОБЯЗАН** вырезать `geminiKeys` и `navyKeys` перед рассылкой GameState клиентам. Клиенты никогда не должны видеть чужие ключи. Приватные секреты игроков рассылаются тоже строго точечно через отдельный сокет-ивент (`secret_data`).
4. **Асимметричный UI:** Если вводится механика для одного игрока, помни про остальных. Игрок А может видеть секрет, пока Игрок Б видит лишь таймер. Учитывай это в `App.tsx`.
5. **Влияние UI на UX:** Использовать анимации (Tailwind `animate-pulse`, `animate-bounce`, кастомные `animate-shake` и эффект встроенной "печатной машинки" в `MarkdownDisplay`), плавные переходы (`transition-all opacity-0 -> 100`) и встроенные функции TWA (`HapticFeedback.impactOccurred`). Тексты сценариев и результатов должны появляться плавно, а секреты запрашивать чтение перед вводом хода. Мы делаем *сочный* Mini App.

## 4. Использование ИИ-инструментов и MCP
1. **Не придумывай интерфейсы для сторонних библиотек:** Если тебе нужно использовать новую фичу Gemini (например, System Instruction или JSON Schema) или Telegram WebApp, используй MCP сервер `context7` (`"use context7 to check Gemini node.js sdk"`).
2. **Правка файлов:** Редактируй код напрямую через предоставленные тулы замены (`replace_file_content`, `write_to_file`). Ищи вхождения через `grep_search`. Не используй Stitch для визуального UI, если нужно править рабочий репозиторий.
3. **Решение циклических ошибок (Anti-Loop):** Если сборка `npm run build` или `npm run test` валится 2 раза на одной и той же проблеме типов, не пытайся менять её слепо в 3-й раз! Возьми паузу, изучи `types.ts` и `tsconfig.json`, распечатай содержимое файлов через консоль или `view_file` для диагностики.

## 5. Обновления и Документирование
Перед завершением задачи в текущей сессии:
1. Запусти `npm run build` (чтобы Vite + `tsc` проверили клиентскую типизацию).
2. Оставь запись в `UPDATES.md`, добавив заголовок формата `## [Дата] - [Суть новой фичи]` и короткое резюме того, какие архитектурные узлы затронуты (например: "Добавлены голосовалки в InteractiveLoadingScreen, обновлен lobbyService"). Обычные багфиксы в UPDATES писать не нужно.